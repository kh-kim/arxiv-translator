# Meltdown

Moritz Lipp\({}^{1}\), Michael Schwarz\({}^{1}\), Daniel Gruss\({}^{1}\), Thomas Prescher\({}^{2}\), Werner Haas\({}^{2}\)

스테판 망가드\({}^{1}\), 폴 코체르\({}^{3}\), 다니엘 젠킨\({}^{4}\), 유발 야롬\({}^{5}\), 마이크 함부르크\({}^{6}\)

\({}^{1}\) _Graz University of Technology_

\({}^{2}\) _Cyberus Technology GmbH__

\({}^{3}\) _Independent_

\({}^{4}\) _펜실베니아 대학교 및 메릴랜드 대학교_

\({}^{5}\) _애들레이드 대학교 및 Data61_

\({}^{6}\) _Rambus, 암호연구부

###### Abstract

컴퓨터 시스템의 보안은 기본적으로 메모리 격리에 의존하는데, 예를 들어 커널 주소 범위는 액세스 불가능으로 표시되고 사용자 액세스로부터 보호된다. 본 논문에서는 Meltdown을 제안한다. 멜트다운은 개인 데이터 및 패스워드를 포함하는 임의의 커널 메모리 위치를 읽기 위해 현대 프로세서에 대한 순서 외 실행의 부작용을 이용한다. 순서 외 실행은 필수 불가결한 성능 기능이며 광범위한 현대 프로세서에 존재한다. 이 공격은 적어도 2010년 이후 다양한 인텔 마이크로 아키텍처에서 작동하며 잠재적으로 다른 프로세서가 영향을 받는다. 멜트다운의 근본 원인은 하드웨어입니다. 공격은 운영 체제와 무관하며 소프트웨어 취약성에 의존하지 않습니다. 멜트다운은 주소 공간 격리에 의해 주어진 모든 보안 가정과 반가상화된 환경을 깨고, 따라서 모든 보안 메커니즘이 이 기반 위에 구축된다. 영향을 받는 시스템에서 Meltdown을 사용하면 공격자가 권한이나 권한 없이 클라우드에서 다른 프로세스 또는 가상 머신의 메모리를 읽을 수 있어 수백만 명의 고객과 개인 컴퓨터의 거의 모든 사용자에게 영향을 미칩니다. KASLR [8]에 대한 KAISER 방어 메커니즘이 멜트다운을 방해하는 중요한(그러나 부주의한) 부작용을 가지고 있음을 보여준다. 우리는 이러한 심각한 정보 유출에 대한 대규모 활용을 방지하기 위해 KAISER를 즉시 배치해야 한다고 강조한다.

## 1 Introduction

오늘날 운영 체제의 핵심 보안 기능 중 하나는 메모리 격리입니다. 운영 체제들은 사용자 애플리케이션들이 서로의 메모리들에 액세스할 수 없도록 보장하고 사용자 애플리케이션들이 커널 메모리를 판독하거나 기록하는 것을 방지한다. 이러한 고립은 컴퓨팅 환경의 초석이며 개인 장치에서 여러 애플리케이션을 실행하거나 클라우드의 단일 컴퓨터에서 여러 사용자의 프로세스를 실행할 수 있다.

현대 프로세서들에서, 커널과 사용자 프로세스들 사이의 격리는 전형적으로 커널의 메모리 페이지가 액세스될 수 있는지 여부를 정의하는 프로세서의 감독자 비트에 의해 실현된다. 기본 아이디어는 이 비트는 커널 코드를 입력할 때만 설정할 수 있고 사용자 프로세스로 전환할 때 지워진다는 것이다. 이러한 하드웨어 특징을 통해 운영체제는 커널을 모든 프로세스의 어드레스 공간으로 매핑하고, 예를 들어 인터럽트 처리를 위해 사용자 프로세스에서 커널로의 매우 효율적인 전환을 가질 수 있다. 결과적으로, 실제로, 사용자 프로세스에서 커널로 전환할 때 메모리 매핑의 변경은 없다.

본 연구에서는 Meltdown1을 제안한다. Meltdown은 커널 영역에 매핑된 모든 물리적 메모리를 포함하여 모든 사용자 프로세스가 실행되는 기계의 전체 커널 메모리를 읽을 수 있는 간단한 방법을 제공함으로써 메모리 격리를 완전히 극복할 수 있는 새로운 공격이다. 멜트다운은 모든 주요 운영 체제에서 작동하는 소프트웨어 취약성을 이용하지 않습니다. 대신, 멜트다운은 2010년 이후 현대 인텔 마이크로 아키텍처와 같은 대부분의 현대 프로세서와 다른 벤더의 다른 CPU에서 사용할 수 있는 부채널 정보를 이용한다.

각주 1: 이 공격은 이 논문의 저자와 Google Project Zero의 Jann Horn에 의해 독립적으로 발견되었다.

부채널 공격들은 전형적으로 타겟 애플리케이션에 대한 매우 특정한 지식을 필요로 하고 타겟 애플리케이션의 비밀들에 대한 정보만을 누설하지만, Meltdown은 취약한 프로세서 상에서 코드를 실행할 수 있는 적대자가 임의의 맵핑된 물리적 메모리를 포함한 전체 커널 어드레스 공간을 쉽게 덤프할 수 있게 한다. 멜트다운의 단순성과 강도의 근본 원인은 _주문 외 실행_으로 인한 부작용입니다.

비순서 실행은 바쁜 실행 유닛의 레이턴시를 극복하기 위해 오늘날의 프로세서의 중요한 성능 특징인데, 예를 들어 메모리 페치 유닛은 메모리로부터의 데이터 도착을 기다려야 한다. 현대의 프로세서는 실행을 지연하는 대신 _순서가 맞지 않는_ 작업을 실행합니다. 즉, 프로세스를 미리 보고 프로세서의 유휴 실행 단위로 후속 작업을 예약합니다. 그러나, 그러한 동작들은 종종 원치 않는 부작용들, 예를 들어, 타이밍 차이들[28, 35, 11]이 순차적 및 비순차적 실행 둘 다로부터 정보를 누설할 수 있다.

보안 관점에서 한 관찰은 특히 중요합니다. 순서 외; 취약한 CPU는 권한 없는 프로세스가 권한 있는(커널 또는 물리적) 주소에서 임시 CPU 레지스터로 데이터를 로드할 수 있도록 합니다. 더욱이, CPU는 심지어 이 레지스터 값에 기초한 추가 계산들, 예를 들어, 레지스터 값에 기초한 어레이에 대한 액세스를 수행한다. 프로세서는 명령어가 실행되어서는 안 된다는 것이 밝혀지면, 메모리 룩업들의 결과들(예를 들어, 수정된 레지스터 상태들)을 단순히 폐기함으로써, 올바른 프로그램 실행을 보장한다. 따라서, 아키텍처 레벨(예를 들어, 프로세서가 계산을 수행해야 하는 방법에 대한 추상적 정의)에서는 보안 문제가 발생하지 않는다.

그러나, 비순차 메모리 검색은 캐시에 영향을 미치며, 이는 다시 캐시 측 채널을 통해 탐지될 수 있음을 관찰했다. 결과적으로, 공격자는 비순서 실행 스트림에서 특권 메모리를 판독함으로써 전체 커널 메모리를 덤프할 수 있고, 마이크로아키텍처 은닉 채널(예를 들어, Flush+Reload)을 통해 이 파악하기 어려운 상태로부터의 데이터를 외부 세계로 전송할 수 있다. 커버트 채널의 수신단에서, 레지스터 값이 재구성된다. 따라서, 마이크로아키텍처 레벨(예를 들어, 실제 하드웨어 구현)에서는 악용 가능한 보안 문제가 있다.

멜트다운은 CPU의 메모리 격리 기능에 의해 주어진 모든 보안 가정을 깨뜨린다. 최신 데스크톱 컴퓨터 및 노트북뿐만 아니라 클라우드의 서버에 대한 공격을 평가했습니다. Meltdown을 사용하면 권한 없는 프로세스가 Linux 및 OS X의 전체 물리적 메모리와 Windows의 물리적 메모리의 큰 부분을 포함하여 커널 주소 공간에서 매핑된 데이터를 읽을 수 있습니다. 이것은 다른 프로세스들의 물리적 메모리, 커널, 및 반가상화 모드에서 커널 공유 샌드박스 솔루션들(예를 들어, 도커, LXC) 또는 Xen의 경우, 커널(또는 하이퍼바이저)의 메모리, 및 다른 공동-위치된 인스턴스들을 포함할 수 있다. 성능은 프로세서 속도, TLB 및 캐시 크기, DRAM 속도와 같은 특정 머신에 크게 의존하지만, 최대 \(503\,\mathrm{KB}/\mathrm{s}\)으로 커널과 물리 메모리를 덤프할 수 있다. 따라서 엄청난 수의 시스템이 영향을 받습니다.

대응책 KAISER [8]은 원래 KASLR을 대상으로 하는 부채널 공격을 방지하기 위해 개발되었으며, 의도치 않게 Meltdown으로부터도 보호한다. 우리의 평가는 KAISER가 멜트다운을 상당 부분 방지한다는 것을 보여준다. 결과적으로, 우리는 KAISER를 모든 운영 체제에 즉시 배치하는 것이 가장 중요하다고 강조한다. 다행히도 책임 있는 공개 창 동안 3대 운영 체제(Windows, Linux 및 OS X)는 KAISER의 변형을 구현했으며 가까운 장래에 이러한 패치를 출시할 것이다.

Meltdown은 Spectre 공격[19]과 여러 면에서 구별되며, 특히 Spectre는 피해 프로세스의 소프트웨어 환경에 맞게 조정해야 하지만 CPU에 더 광범위하게 적용되며 KAISER에 의해 완화되지 않는다.

기여. 이 작업의 기여는 다음과 같다:

1. 순서 외 실행을 새롭고 매우 강력한 소프트웨어 기반 사이드 채널로 설명합니다.
2. 우리는 어떻게 비순서 실행이 마이크로아키텍쳐 은닉 채널과 결합되어 데이터를 파악하기 어려운 상태에서 외부에 있는 수신기로 전송할 수 있는지를 보여준다.
3. 예외 처리기 또는 TSX를 사용 하 여 순서 외 실행을 결합 하 여 랩톱, 데스크톱 컴퓨터 및 공용 클라우드 컴퓨터에서 권한이나 권한 없이 임의 물리적 메모리를 읽는 종단 간 공격을 제시 합니다.
4. Meltdown의 성능 및 KAISER의 영향을 평가하였다.

본 논문의 나머지 부분은 다음과 같이 구성되어 있다. 2절에서는 비순서적 실행과 함께 도입되는 근본적인 문제를 설명한다. 섹션 3에서, 우리는 사이드 채널 멜트다운 악용들을 예시하는 장난감 예를 제공한다. 섹션 4에서는 풀 멜트다운 공격의 구성 요소를 설명한다. 섹션 5에서 우리는 용융 공격을 제시한다. 섹션 6에서는 여러 다른 시스템에 대한 멜트다운 공격의 성능을 평가한다. 섹션 7에서는 소프트웨어 기반 KAISER 대응책의 효과에 대해 논의하고 하드웨어에서 해결책을 제안한다. 8절에서는 관련 작업에 대해 논의하고 9절에서 우리의 작업을 마무리한다.

## 2 Background

이 섹션에서는 순서 외 실행, 주소 변환 및 캐시 공격에 대 한 백그라운드를 제공 합니다.

### Out-of-order execution

순서 외 실행은 CPU 코어의 모든 실행 유닛의 활용도를 최대한 극대화할 수 있도록 하는 최적화 기법이다. 순차적인 프로그램 순서로 엄격하게 명령들을 처리하는 대신에, CPU는 필요한 모든 리소스들이 이용가능한 즉시 명령들을 실행한다. 현재 동작의 실행 유닛이 점유되는 동안, 다른 실행 유닛들이 전방으로 주행할 수 있다. 따라서, 명령어는 그 결과가 아키텍처 정의를 따르는 한 병렬로 실행될 수 있다.

실제로, 비순차 실행을 지원하는 CPU는 명령어가 필요하고 커밋될지 여부가 확실하기 전에 프로세서의 비순차 로직이 명령어를 처리하는 정도로 _명확하게_ 연산을 실행하도록 지원한다. 본 논문에서는 분기를 따르는 명령어 시퀀스를 지칭하는 보다 제한된 의미의 추측적 실행을 지칭하고, 프로세서가 모든 사전 명령어의 결과를 커밋하기 전에 연산을 실행하는 모든 방법을 지칭하기 위해 비순서적 실행이라는 용어를 사용한다.

1967년에 토마술로[33]는 명령어의 동적 스케줄링을 가능하게 하여 순서 외 실행을 허용하는 알고리즘[33]을 개발했다. 토마술로[33]는 CPU가 데이터 값을 레지스터에 저장하고 다시 읽는 대신 연산된 대로 사용할 수 있는 통합 예약 스테이션을 도입했다. 예약 스테이션은 동일한 물리적 레지스터 상에서 동작하는 명령어가 마지막 논리적 레지스터를 사용하여 RAW(read-after-write), WAR(write-after-read) 및 WAW(write-after-write) 위험을 해결할 수 있도록 레지스터의 이름을 변경한다. 나아가, 예약부는 모든 실행부를 공통 데이터 버스(CDB)를 통해 연결한다. 오퍼랜드가 이용가능하지 않은 경우, 예약 유닛은 이용가능할 때까지 CDB 상에서 청취한 다음 명령의 실행을 직접 시작할 수 있다.

인텔 아키텍처 상에서, 파이프라인은 프론트-엔드, 실행 엔진(백-엔드) 및 메모리 서브시스템[14]으로 구성된다. x86 명령어들은 메모리로부터 프론트-엔드에 의해 인출되고 실행 엔진으로 연속적으로 전송되는 마이크로-동작들(\(\mu\)OP들)로 디코딩된다. 순서 외 실행은 그림 1과 같이 실행 엔진 내에서 구현됩니다. _순서 버퍼_는 레지스터 할당, 레지스터 이름 변경 및 은퇴를 담당합니다. 또한 이동 제거 또는 제로로잉 숙어 인식과 같은 다른 최적화는 재정렬 버퍼에 의해 직접 처리된다. \(\mu\)OP는 _실행 단위_ 에 연결 된 출구 포트에서 작업을 대기 하는 _Unified Reservation Station_ 으로 전달 됩니다. 각각의 실행 유닛은 ALU 동작, AES 동작, 어드레스 생성 유닛(AGU) 또는 메모리 로드 및 저장과 같은 상이한 태스크를 수행할 수 있다. 부하 및 저장 실행 유닛뿐만 아니라 AGU는 메모리 서브시스템에 직접 연결되어 그 요청을 처리한다.

CPU는 일반적으로 선형 명령어 스트림을 실행하지 않기 때문에, 다음에 어떤 명령어가 실행될지에 대한 교육된 추측을 얻기 위해 사용되는 분기 예측 유닛을 갖는다. 분기 예측 변수는 조건이 실제로 평가되기 전에 분기의 방향을 결정하려고 합니다. 해당 경로에 놓여 있고 종속성이 없는 명령어는 미리 실행될 수 있으며 예측이 정확하다면 그 결과를 즉시 사용할 수 있다. 예측이 부정확한 경우, 재정렬 버퍼는 재정렬 버퍼를 클리어하고 통일된 예약 스테이션을 재초기화함으로써 롤백을 허용한다.

분기를 예측하기 위한 다양한 접근법들이 존재한다: 정적 분기 예측 [12]을 가지고, 분기의 결과는 오로지 명령 자체에 기초한다. 동적 분기 예측 [2]는 런타임에 통계를 수집 하 여 결과를 예측 합니다. 1-레벨 브랜치 예측은 1-비트 또는 2-비트 카운터를 사용하여 브랜치의 마지막 결과를 기록한다[21]. 현대의 프로세서는 종종 마지막 \(n\) 결과의 이력을 기억하는 2-레벨 적응 예측기[36]를 사용하여 규칙적으로 반복되는 패턴을 예측할 수 있다. 보다 최근에, 신경 분기 예측[34, 18, 32]을 사용하기 위한 아이디어들이 픽업되어 CPU 아키텍처들[3]에 통합되었다.

### Address Spaces

프로세스들을 서로 분리하기 위해, CPU들은 가상 어드레스들이 물리적 어드레스들로 변환되는 가상 어드레스 공간들을 지원한다. 다단계 페이지 번역을 통해 물리적 메모리에 개별적으로 매핑될 수 있는 페이지들의 집합으로 가상 주소 공간을 분할하는

그림 1: 인텔의 스카이라크 마이크로아키텍처의 단일 코어에 대한 간략한 그림. 명령어들은 \(\mu\)OP들로 디코딩되고, 개별 실행 유닛들에 의해 실행 엔진에서 비순서적으로 실행된다.

테이블. 변환 테이블은 실제 가상에서 물리적 매핑을 정의 하 고 읽기, 쓰기, 실행 가능 및 사용자 액세스 가능과 같은 권한 검사를 적용 하는 데 사용 되는 보호 속성을 정의 합니다. 현재 사용되는 변환 테이블은 특수 CPU 레지스터에 보관됩니다. 각 컨텍스트 스위치에서 운영 체제는 프로세스 가상 주소 공간당 구현하기 위해 다음 프로세스의 변환 테이블 주소로 이 레지스터를 업데이트한다. 그 때문에, 각각의 프로세스는 자신의 가상 어드레스 공간에 속하는 데이터만을 참조할 수 있다. 각각의 가상 주소 공간 자체는 사용자와 커널 부분으로 분할된다. 사용자 어드레스 공간이 실행중인 애플리케이션에 의해 액세스될 수 있는 동안, 커널 어드레스 공간은 CPU가 특권 모드에서 실행중인 경우에만 액세스될 수 있다. 이는 운영 체제가 해당 변환 테이블의 사용자 액세스 가능 속성을 비활성화함으로써 적용됩니다. 커널 어드레스 공간은 커널 자신의 사용을 위해 매핑된 메모리를 가질 뿐만 아니라, 사용자 페이지들에 대한 동작들, 예를 들어, 이들을 데이터로 채우는 동작을 수행할 필요가 있다. 결과적으로, 전체 물리적 메모리는 전형적으로 커널에서 매핑된다. Linux 및 OS X에서 직접 물리적 맵 _i.e_를 통해 수행 되며 전체 물리적 메모리는 미리 정의 된 가상 주소에 직접 매핑 됩니다 (cf. 그림 2).

직접 물리적 맵 대신 Windows는 여러 개의 소위 호출된 풀_, 호출되지 않은 풀_ 및 시스템 캐시_를 유지 관리합니다. 이들 풀들은 물리적 페이지들을 가상 어드레스들에 매핑하는 커널 어드레스 공간 내의 가상 메모리 영역들로서, 메모리(페이징되지 않은 풀)에 남아있도록 요구되거나 또는 사본이 디스크(페이징된 풀)에 이미 저장되어 있기 때문에 메모리로부터 제거될 수 있다. **시스템 캐시** 에는 모든 파일 백업 페이지의 매핑이 더 포함되어 있습니다. 결합된, 이러한 메모리 풀들은 전형적으로 물리적 메모리의 큰 부분을 모든 프로세스의 커널 어드레스 공간으로 맵핑할 것이다.

메모리 손상 버그를 활용하려면 특정 데이터의 주소에 대한 지식이 필요한 경우가 많습니다. 이러한 공격을 방해하기 위해, 실행 불가능한 스택 및 스택 카나리뿐만 아니라 주소 공간 레이아웃 랜덤화(ASLR: address space layout randomization)가 도입되었다. KASLR은 커널을 보호하기 위해 모든 부팅에서 드라이버가 위치한 오프셋을 랜덤화하여 커널 데이터 구조의 위치를 추측해야 하기 때문에 공격을 더 어렵게 만든다. 그러나, 부채널 공격은 커널 데이터 구조의 정확한 위치를 검출하거나 자바스크립트[6]에서 ASLR을 디랜덤화할 수 있다[9, 13, 17]. 소프트웨어 버그와 이러한 주소에 대한 지식의 조합은 권한 있는 코드 실행으로 이어질 수 있다.

### Cache Attacks

메모리 액세스 및 주소 변환 속도를 높이기 위해 CPU에는 자주 사용되는 데이터를 저장하는 캐시라고 하는 작은 메모리 버퍼가 포함되어 있습니다. CPU 캐시는 자주 사용되는 데이터를 더 작고 빠른 내부 메모리에 버퍼링하여 느린 메모리 액세스 대기 시간을 숨깁니다. 최신 CPU에는 코어에 비공개 또는 코어 간에 공유되는 여러 수준의 캐시가 있습니다. 주소 공간 변환 테이블도 메모리에 저장되며 일반 캐시에도 캐시됩니다.

캐시 부채널 공격은 캐시들에 의해 도입되는 타이밍 차이를 이용한다. Evict+Time [28], Prime+Probe [28, 29], Flush+Reload [35]를 포함한 다양한 캐시 공격 기법이 과거에 제안되고 시연되었다. 플러시+재로드 공격은 단일 캐시 라인 세분성에서 작동합니다. 이러한 공격은 공유된 마지막 수준 캐시를 이용합니다. 공격자는 플러시 명령을 사용하여 대상 메모리 위치를 자주 플러시합니다. 공격자는 데이터를 다시 로드하는 데 걸리는 시간을 측정하여 그 동안 다른 프로세스에 의해 데이터가 캐시에 로드되었는지 여부를 결정한다. Flush+Reload 공격은 암호 알고리즘 [35, 16, 1], 웹 서버 함수 호출 [37], 사용자 입력 [11, 23, 31], 커널 주소 지정 정보 [9]와 같은 다양한 계산에 대한 공격에 사용되었다.

특수 사용 케이스는 비밀 채널입니다. 여기서 공격자는 부작용을 유발하는 부분과 부작용을 측정하는 부분을 모두 통제한다. 이것은 아키텍처 레벨 또는 그 위에 존재하는 임의의 경계를 우회하면서, 하나의 보안 도메인으로부터 다른 도메인으로 정보를 유출하는 데 사용될 수 있다. 프라임+프로브와 플러시+리로드 모두 고성능 비밀 채널[24, 26, 10]에 사용되었습니다.

## 3 A 장난감 예시

이 절에서는 비순서 실행이 정보를 유출하는 방식으로 미세 구조 상태를 변경할 수 있음을 설명하기 위해 장난감 예제인 심플 코드 조각으로 시작한다. 그러나 그 단순성에도 불구하고 이 상태 변화가 공격에 어떻게 악용될 수 있는지 보여주는 섹션 4와 섹션 5의 기반으로 사용된다.

목록 1은 먼저 (처리 되지 않은) 예외를 제기 한 다음 배열에 액세스 하는 심플 코드 조각입니다. 예외의 속성은 제어 흐름이 그렇지 않다는 것이다.

도 2: 물리적 메모리는 특정 오프셋에서 커널에서 직접 매핑된다. 사용자 공간에 대해 액세스 가능한 매핑되는 물리 주소(블루)도 직접 매핑을 통해 커널 공간 내에 매핑된다.

예외 후 코드를 계속 사용하지만 운영 체제에서 예외 처리기로 이동합니다. 이 예외가 메모리 액세스, 예를 들어 무효한 어드레스에 액세스함으로써 또는 임의의 다른 CPU 예외, 예를 들어 0에 의한 분할로 인해 제기되는지 여부에 관계없이, 제어 흐름은 다음 사용자 공간 명령과 함께가 아니라 커널에서 계속된다.

따라서 예외가 커널에 즉시 트랩하고 응용 프로그램을 종료하기 때문에 우리의 장난감 예는 이론적으로 배열에 액세스할 수 없다. 그러나 순서 외 실행으로 인해 CPU는 예외에 대한 종속성이 없기 때문에 이미 다음 명령을 실행했을 수 있습니다. 이것은 도 3에 예시되어 있다. 예외로 인해, 순서 없이 실행되는 명령들은 은퇴되지 않고, 따라서, 결코 아키텍처 효과를 갖지 않는다.

순서 없이 실행되는 명령어는 레지스터나 메모리에 가시적인 구조적 영향을 미치지 않지만 마이크로아키텍처적 부작용을 가지고 있다. 순서가 어긋난 실행 동안, 참조된 메모리는 레지스터로 인출되고 또한 캐시에 저장된다. 순서가 아닌 실행을 취소해야 하는 경우 레지스터 및 메모리 내용은 절대 커밋되지 않습니다. 그럼에도 불구하고, 캐싱된 메모리 컨텐츠는 캐시에 유지된다. 특정 메모리 위치가 캐싱되었는지 여부를 감지하는 Flush+Reload [35]와 같은 미세 구조 부채널 공격을 활용하여 이러한 미세 구조 상태를 볼 수 있다. 프라임+프로브[28, 24, 26], Evict+Reload[23] 또는 Flush+Flush[10]를 포함하여 특정 메모리 위치가 캐시되었는지 여부를 감지하는 다른 사이드 채널도 있다. 그러나 Flush+Reload는 가장 정확한 캐시 측 채널이며 구현이 간단하기 때문에 이 예에서는 다른 측 채널을 고려하지 않는다.

이 장난감 예에서 데이터의 값에 기초하여, 메모리 액세스를 순서 없이 실행할 때 캐시의 상이한 부분이 액세스된다. 데이터에 4096이 곱해짐에 따라 프로브_어레이에 대한 데이터 액세스는 4kB의 거리(프로브_어레이에 대한 1B 데이터 유형을 가정함)로 어레이 위에 산란된다. 따라서 데이터의 값에서 메모리 페이지로의 인젝티브 매핑(injective mapping, _i.e.)이 존재하여 서로 다른 두 개의 데이터 값이 존재하지 않아 동일한 페이지에 접근할 수 있으며, 결과적으로 페이지의 캐시 라인이 캐싱되면 데이터의 값을 알 수 있다. 상이한 페이지들에 걸친 확산은 프리페처가 페이지 경계들을 가로지르는 데이터에 액세스할 수 없기 때문에, 프리페처로 인한 잘못된 긍정들을 제거한다[14].

그림 4는 데이터 = 84인 비순차 스니펫을 실행한 후 모든 페이지에 대해 Flush+Reload 측정을 반복한 결과를 보여준다. 예외로 인해 배열 액세스가 발생하지 않았어야 했지만, 액세스했을 인덱스가 캐시되어 있음을 분명히 알 수 있다. 모든 페이지들에 걸쳐 반복하는 것(예를 들어, 예외 핸들러에서)은 단지 페이지 84에 대한 캐시 히트를 보여준다. 이것은 실제로 실행되지 않는 명령들조차도 CPU의 마이크로아키텍처 상태를 변경한다는 것을 보여준다. 섹션 4는 이 장난감 예제를 수정하여 값을 읽지 않고 액세스할 수 없는 비밀을 누설합니다.

## 4 Building Block of the Attack

섹션 3의 장난감 예는 순서 외 실행의 부작용이 미세 구조 상태를 수정하여 정보를 유출할 수 있음을 보여주었다. 코드 조각은 캐시 쪽 채널에 전달 된 데이터 값을 표시 하지만 이 기술을 활용 하 여 액세스할 수 없는 비밀을 누출 하는 방법을 보여 줍니다. 본 절에서는 공격에 대해 비순서적 실행을 악용하기 위해 필요한 구성 요소를 일반화하고 논의하고자 한다.

그림 4: 메모리 위치가 순서 외 실행 중에만 액세스되더라도 캐시된 상태로 유지됩니다. 프로브 어레이의 256 페이지에 걸쳐 반복하는 것은 순서 없는 실행 동안 액세스된 페이지에서 정확히 하나의 캐시 히트를 보여준다.

도 3: 실행된 명령이 예외를 야기하는 경우, 제어 흐름을 예외 핸들러로 전환하면, 후속 명령은 더 이상 실행되지 않아야 한다. 순서가 어긋나는 실행으로 인해 후속 명령은 이미 부분적으로 실행되었을 수 있지만 은퇴하지는 않았다. 그러나, 실행의 아키텍처 효과는 폐기될 것이다.

적국은 물리적 기억 어딘가에 보관되어 있는 비밀 값을 목표로 한다. 레지스터 콘텐츠들은 또한 콘텍스트 스위치들, _i.e._ 시에 메모리에 저장되며, 그것들은 또한 물리적 메모리에 저장된다는 것에 유의한다. 섹션 2.2에 설명된 바와 같이, 모든 프로세스의 어드레스 공간은 전형적으로 전체 사용자 공간뿐만 아니라 전체 커널 공간을 포함하며, 이는 전형적으로 또한 매핑된 모든 물리적 메모리(사용중)를 갖는다. 그러나, 이들 메모리 영역은 특권 모드에서만 액세스 가능하다(cf. 섹션 2.2).

본 연구에서는 특권 모드 격리를 우회하여 공격자가 다른 프로세스의 물리적 메모리와 커널을 포함하여 매핑된 물리적 메모리를 포함한 전체 커널 공간에 대한 완전한 읽기 액세스를 제공함으로써 비밀 누설을 보여준다. Kocher 등[19]은 Spectre Attacks라고 불리는 직교 접근법을 추구하는데, 이는 추측적으로 실행된 명령어를 희생자 프로세스가 액세스할 수 있는 권한이 있는 정보를 누설하도록 속인다. 결과적으로 스펙터 공격은 멜트다운의 특권 강화 측면이 부족하고 피해 프로세스의 소프트웨어 환경에 맞게 조정해야 하지만, 투기적 실행을 지원하고 KAISER에 의해 중단되지 않는 CPU에 더 광범위하게 적용한다.

전체 멜트다운 공격은 그림 5와 같이 두 개의 빌딩 블록으로 구성된다. 멜트다운의 첫 번째 빌딩 블록은 CPU가 실행된 경로에서 결코 발생하지 않을 하나 이상의 명령을 실행하도록 하는 것이다. 장난감 예(cf. 섹션 3)에서, 이전 명령에서 항상 예외를 제기 하기 때문에 일반적으로 실행 되지 않는 배열에 대 한 액세스입니다. 우리는 측정 가능한 부작용을 남기고 순서가 어긋나게 실행되는 그러한 명령을 _일시적인 명령_이라고 부른다. 또한, 우리는 적어도 하나의 과도 명령어를 포함하는 명령어 시퀀스를 과도 명령어 시퀀스라고 부른다.

일시적 명령어를 공격에 활용하기 위해, 일시적 명령어 시퀀스는 공격자가 유출하고자 하는 비밀 값을 활용해야 한다. 섹션 4.1은 비밀 값에 대한 의존성을 갖는 일시적 명령 시퀀스를 실행하기 위한 빌딩 블록들을 설명한다.

멜트다운의 두 번째 빌딩 블록은 일시적 명령 시퀀스의 미세구조적 부작용을 아키텍처 상태로 전달하여 누출된 비밀을 추가로 처리하는 것이다. 따라서, 섹션 4.2에 설명된 두 번째 건물은 은밀한 채널을 사용하여 마이크로아키텍처적 부작용을 건축 상태로 전달하기 위한 빌딩 블록들을 설명한다.

### Transient 명령어 실행

멜트다운의 첫 번째 구성 요소는 일시적인 명령의 실행이다. 일시적인 명령어는 기본적으로 항상 발생하는데, CPU가 경험된 레이턴시를 최소화하고 따라서 성능을 최대화하기 위해 현재 명령어에 앞서 지속적으로 실행되기 때문이다(cf. 섹션 2.1). 일시적인 명령어들은 그들의 동작이 비밀 값에 의존하는 경우 악용 가능한 사이드 채널을 도입한다. 공격자의 프로세스 내에서 매핑되는 주소 _i.e._, 사용자 액세스 가능 사용자 공간 주소 및 사용자 액세스 불가능 커널 공간 주소에 중점을 둡니다. 다른 프로세스의 컨텍스트(_i.e._, 어드레스 공간) 내에서 실행되는 코드를 대상으로 하는 공격은 [19] 가능하지만, 어쨌든 모든 물리적 메모리(다른 프로세스의 메모리를 포함함)는 커널 어드레스 공간을 통해 판독될 수 있기 때문에, 본 작업에서는 범위를 벗어난다.

커널 페이지와 같이 사용자가 액세스할 수 없는 페이지에 액세스하면 일반적으로 애플리케이션을 종료하는 예외가 트리거됩니다. 공격자가 사용자가 액세스할 수 없는 주소에 있는 비밀을 대상으로 하는 경우 공격자는 이 예외에 대처해야 합니다. 우리는 두 가지 접근 방법을 제안한다: _예외 처리_를 사용하면 과도 명령 시퀀스를 실행한 후 예외가 효과적으로 발생하는 것을 포착하고, _예외 억제_를 사용하면 예외가 전혀 발생하지 않도록 하고 대신 과도 명령 시퀀스를 실행한 후 제어 흐름을 리디렉션한다. 우리는 다음에서 이러한 접근법에 대해 자세히 논의한다.

예외 처리.사소한 접근법은 프로세스를 종료하는 무효 메모리 위치에 액세스하기 전에 공격 애플리케이션을 포크하고, 자식 프로세스에서 무효 메모리 위치에만 액세스하는 것이다. 상기 CPU는 상기 과도 명령 시퀀스를 상기 프로세서에서 실행시키는

도 5: 멜트다운 공격은 일련의 일시적 명령어를 실행하기 위해 예외 처리 또는 억제, 예를 들어 TSX를 사용한다. 이러한 과도 명령어는 (지속적인) 비밀 값을 획득하고, 이 비밀 값에 기초하여 프로세서의 미세 구조 상태를 변경한다. 이것은 마이크로아키텍처 비밀 채널의 송신 부분을 형성한다. 수신측은 마이크로아키텍쳐 상태를 판독하여 건축적으로 만들고 비밀 가치를 회복한다.

충돌하기 전에 아동 과정입니다. 그 다음, 부모 프로세스는 예를 들어, 부채널을 통해 미세구조 상태를 관찰함으로써 비밀을 복구할 수 있다.

또한, 특정 예외가 발생하면 실행될 신호 핸들러를 설치할 수 있으며, 이 특정 경우에는 세그멘테이션 폴트이다. 이를 통해 공격자는 명령어 시퀀스를 발행하고 애플리케이션이 충돌하는 것을 방지하여 새로운 프로세스를 생성하지 않아도 되므로 오버헤드를 줄일 수 있다.

예외 억제.예외를 다루는 다른 접근법은 애초에 그들이 제기되는 것을 막는 것이다. 트랜잭션 메모리는 메모리 액세스를 하나의 원자적 연산으로 그룹화하여 오류가 발생하면 이전 상태로 롤백할 수 있는 옵션을 제공합니다. 트랜잭션 내에서 예외가 발생하면 아키텍처 상태가 재설정되고 프로그램 실행이 중단 없이 계속됩니다.

또한, 추론적 실행은 분기 예측 오류로 인해 실행된 코드 경로에서 발생하지 않을 수 있는 명령을 발행한다. 선행 조건 분기에 의존하는 이러한 명령은 추측적으로 실행될 수 있다. 따라서, 무효 메모리 액세스는 사전 분기 조건이 참으로 평가된 경우에만 실행되는 추측 명령 시퀀스 내에 놓인다. 실행된 코드 경로에서 조건이 참으로 평가되지 않도록 함으로써 메모리 액세스가 추측적으로만 실행되기 때문에 발생하는 예외를 억제할 수 있다. 이 기법은 분기 예측기의 정교한 훈련을 필요로 할 수 있다. Kocher 등[19]은 직교 작업에서 이러한 접근법을 추구하는데, 그 이유는 이 구성이 다른 프로세스의 코드에서 자주 발견될 수 있기 때문이다.

### Covert 채널 구성

멜트다운의 두 번째 빌딩 블록은 일시적 명령 시퀀스에 의해 변경된 마이크로아키텍쳐 상태를 아키텍처 상태로 전달하는 것이다(cf. 도 5). 과도한 명령어 시퀀스는 마이크로아키텍쳐 은닉 채널의 송신단으로 볼 수 있다. 은밀한 채널의 수신단은 마이크로아키텍쳐 상태 변화를 수신하고 상태로부터 비밀을 추론한다. 수신기는 과도 명령 시퀀스의 일부가 아니며, 상이한 스레드 또는 심지어 상이한 프로세스, 예를 들어 포크 앤 크래시 접근법에서의 부모 프로세스일 수 있다는 점에 유의한다.

캐시 상태는 다양한 기법을 사용하여 아키텍처 상태로 안정적으로 전달될 수 있는 마이크로 아키텍처 상태이기 때문에, 우리는 캐시 공격으로부터 기술을 활용한다[28, 35, 10]. 특히 플러시+ 재로드 [35]를 사용하여 빠르고 저소음 비밀 채널을 구축할 수 있습니다. 따라서, 비밀 값에 따라, 과도 명령 시퀀스(cf. 섹션 4.1) 예를 들어, 장난감 예(cf. 섹션 3)에서와 같이 규칙적인 메모리 액세스를 수행한다.

일시적인 명령 시퀀스가 액세스 가능한 주소 _i.e._에 액세스한 후 은밀한 채널의 발신자입니다. 주소는 후속 액세스를 위해 캐시됩니다. 그 후, 수신기는 어드레스에 대한 액세스 시간을 측정함으로써 어드레스가 캐시에 로딩되었는지 여부를 모니터링할 수 있다. 따라서, 송신자는 모니터링된 캐시에 로딩되는 어드레스에 액세스함으로써 '1'-비트를 전송할 수 있고, 그러한 어드레스에 액세스하지 않음으로써 '0'-비트를 전송할 수 있다.

섹션 3의 장난감 예제에서와 같이 여러 개의 다른 캐시 라인을 사용하면 여러 비트를 한 번에 전송할 수 있습니다. 256개의 상이한 바이트 값들 각각에 대해, 송신자는 상이한 캐시 라인에 액세스한다. 256개의 가능한 캐시 라인 모두에 대해 Flush+Reload 공격을 수행함으로써, 수신기는 단지 하나의 비트 대신에 전체 바이트를 복구할 수 있다. 그러나 Flush+Reload 공격은 일시적인 명령어 시퀀스보다 훨씬 더 긴 시간(일반적으로 수백 사이클)을 소요하기 때문에 한 번에 한 비트만 전송하는 것이 더 효율적이다. 공격자는 그에 따라 비밀 값을 시프트하고 마스킹함으로써 간단히 할 수 있다.

은밀한 채널은 캐시에 의존하는 마이크로아키텍쳐 상태들로 제한되지 않는다는 것에 유의한다. 지시(시퀀스)에 의해 영향을 받을 수 있고 측면 채널을 통해 관찰할 수 있는 모든 미세 구조 상태는 은밀한 채널의 송신단을 구축하는 데 사용될 수 있다. 송신자는 예를 들어, ALU와 같은 특정 실행 포트를 점유하는 명령(시퀀스)을 발행하여 '1'-비트를 송신할 수 있다. 수신기는 동일한 실행 포트에서 명령어(시퀀스)를 실행할 때의 레이턴시를 측정한다. 높은 레이턴시는 송신자가 '1'-비트를 보내는 것을 의미하고, 낮은 레이턴시는 송신자가 '0'-비트를 보내는 것을 의미한다. Flush+ Reload 캐시 커버트 채널의 장점은 잡음 저항과 높은 전송률이다[10]. 더욱이, 누출은 임의의 CPU 코어로부터 관찰될 수 있다[35], _즉_, 재스케줄링 이벤트들은 은밀한 채널에 큰 영향을 미치지 않는다.

## 5 Meltdown

이 섹션에서는 섹션 4에 제시된 구성 블록으로 구성된 권한 없는 사용자 프로그램에서 임의 물리적 메모리를 읽을 수 있는 강력한 공격인 멜트다운을 제시한다. 먼저 이 공격의 광범위한 적용 가능성을 강조하기 위해 공격 설정에 대해 논의한다. 둘째, Meltdown이 어떻게 개인용 컴퓨터뿐만 아니라 클라우드에서도 윈도우와 리눅스 모두에 탑재될 수 있는지를 보여주는 공격 개요를 제시한다. 마지막으로, 최대 503 \(\mathrm{KB/s}\)의 커널 메모리를 덤프할 수 있는 멜트다운의 구체적인 구현에 대해 논의한다.

공격 설정.공격에서는 클라우드에서 개인용 컴퓨터와 가상 컴퓨터를 고려합니다. 공격 시나리오에서 공격자는 공격 된 시스템에서 임의 권한 없는 코드 실행 _i.e_ 이 있습니다. 공격자는 일반 사용자의 권한으로 모든 코드를 실행할 수 있습니다. 그러나 공격자는 컴퓨터에 대한 물리적 액세스 권한이 없습니다. 또한, SMAP, SMEP, NX 및 PXN과 같은 CPU 기능뿐만 아니라 ASLR 및 KASLR과 같은 최첨단 소프트웨어 기반 방어로 시스템을 완전히 보호한다고 가정한다. 가장 중요한 것은 완전히 버그가 없는 운영 체제를 가정하기 때문에 커널 권한을 얻거나 정보를 유출하는 데 악용될 수 있는 소프트웨어 취약성이 존재하지 않는다는 것이다. 공격자는 비밀 사용자 데이터(예: 암호 및 개인 키) 또는 기타 중요한 정보를 대상으로 합니다.

### Attack Description

멜트다운은 섹션 4에서 논의된 두 빌딩 블록들을 결합한다. 먼저, 공격자는 CPU가 물리적 메모리 어딘가에 저장된 액세스 불가능한 비밀 값을 사용하는 일시적 명령 시퀀스를 실행하게 한다(cf. 섹션 4.1). 과도 명령 시퀀스는 은밀한 채널의 송신기로서 작용한다(cf. 섹션 4.2) 결국 공격자에게 비밀 값을 누설합니다.

멜트다운은 3단계로 이루어진다:

**1단계**: 공격자가 액세스할 수 없는 공격자가 선택한 메모리 위치의 콘텐츠가 레지스터에 로드됩니다.
**2단계**: 일시적인 명령은 레지스터의 비밀 내용에 따라 캐시 라인에 액세스 합니다.
**3단계**: 공격자는 Flush+Reload를 사용하여 액세스된 캐시 라인 및 선택한 메모리 위치에 저장된 비밀을 확인합니다.

상이한 메모리 위치들에 대해 이러한 단계들을 반복함으로써, 공격자는 전체 물리적 메모리를 포함하여 커널 메모리를 덤프할 수 있다.

목록 2는 x86 어셈블리 명령어들을 사용하는, 과도 명령 시퀀스의 기본 구현 및 은밀한 채널의 송신 부분을 도시한다. 이 공격 부분은 C와 같은 상위 언어로도 완전히 구현될 수 있습니다. 다음에서는 Meltdown의 각 단계와 목록 2의 해당 코드 라인에 대해 설명합니다.

1단계: 비밀을 읽는다. 메인 메모리로부터의 데이터를 레지스터에 로딩하기 위해, 메인 메모리 내의 데이터는 가상 어드레스를 사용하여 참조된다. 가상 어드레스를 물리적 어드레스로 변환하는 것과 병행하여, CPU는 또한 이 가상 어드레스가 사용자에 액세스가능한지 또는 커널에 의해서만 액세스가능한지 가상 어드레스 _i.e._의 허가 비트들을 체크한다. 섹션 2.2에서 이미 논의된 바와 같이, 허가 비트를 통한 이러한 하드웨어 기반 격리는 하드웨어 공급자에 의해 안전한 것으로 간주되고 권장된다. 따라서, 현대의 운영체제는 항상 모든 사용자 프로세스의 가상 주소 공간에 전체 커널을 매핑한다.

결과적으로, 모든 커널 어드레스는 그들을 번역할 때 유효한 물리적 어드레스로 이어지고, CPU는 그러한 어드레스의 콘텐츠에 액세스할 수 있다. 사용자 공간 주소에 액세스하는 것의 유일한 차이점은 CPU가 현재의 허가 레벨이 그러한 주소에 액세스하는 것을 허용하지 않기 때문에 예외를 제기한다는 것이다. 따라서, 사용자 공간은 이러한 주소의 내용을 단순히 읽을 수 없다. 그러나 멜트다운은 현대 CPU의 비순서적 실행을 악용하며, 이는 여전히 불법 메모리 접근과 예외의 제기 사이의 작은 시간 창에서 명령을 실행한다.

목록 2의 4행에서는 RCX 레지스터에 저장된 타겟 커널 주소에 위치한 바이트 값을 AL로 표현되는 RAX 레지스터의 최하위 바이트에 로드한다. 섹션 2.1에서 더 상세히 설명되는 바와 같이, MOV 명령은 코어에 의해 페치되고, \(\mu\)OP들로 디코딩되고, 할당되고, 재순서 버퍼로 전송된다. 그곳에서, 아키텍처 레지스터들(예를 들어, 목록 2의 RAX 및 RCX)은 비순차 실행을 가능하게 하는 기초 물리적 레지스터들에 매핑된다. 파이프라인을 최대한 활용 하려고 하면 후속 명령 (라인 5-7)도 이미 디코딩 되 고 \(\mu\)OPs로 할당 됩니다. \(\mu\)OP들은 대응하는 실행 유닛에 의해 실행되기를 기다리는 동안 상기 \(\mu\)OP들을 보유하는 예약 스테이션으로 더 전송된다. \(\mu\)OP의 실행은 실행 단위가 이미 해당 용량에 사용되었거나 아직 계산되지 않은 경우 지연될 수 있다.

커널 어드레스가 라인 4에 로딩될 때, CPU는 이미 아웃-오더 실행의 일부로서 후속 명령어들을 발행하고, 그들의 대응하는 \(\mu\)OP들은 커널 어드레스의 콘텐츠가 도착하기 위해 예약 스테이션에서 대기할 가능성이 있다. 페치된 데이터가 공통 데이터 버스에서 관찰되면, \(\mu\)OP는 실행을 시작할 수 있다.

\(\mu\)OP는 실행을 마치면 순서대로 은퇴하게 되고, 따라서 그 결과는 아키텍처 상태에 전념하게 된다. 은퇴 중에는 명령 실행 중에 발생한 중단 및 예외가 처리됩니다. 따라서, 커널 어드레스를 로딩하는 MOV 인스트럭션이 은퇴되면, 예외가 등록되고 파이프라인이 플러시되어 순서 없이 실행되었던 후속 인스트럭션들의 모든 결과들이 제거된다. 그러나 이 예외를 제기하는 것과 아래에서 설명하는 공격 단계 2 사이에는 경쟁 조건이 있다.

Gruss 등에 의해 보고된 바와 같이, 커널 어드레스들을 프리페칭하는 것이 때때로 성공한다. 커널 주소를 선인출하는 것은 일부 시스템에 대한 공격의 성능을 약간 향상시킬 수 있다는 것을 발견했다.

단계 2: 비밀을 전송하는 단계.순서가 어긋나게 실행되는 단계 1로부터의 명령 시퀀스는 일시적인 명령 시퀀스가 되는 방식으로 선택되어야 한다. 이 과도 명령 시퀀스가 MOV 명령이 은퇴하기 전에 실행되고(_i.e._, 예외를 제기), 과도 명령 시퀀스가 비밀에 기초하여 계산을 수행하면, 공격자에게 비밀을 전송하는데 활용될 수 있다.

이미 논의한 바와 같이, 우리는 CPU의 캐시를 사용하여 빠르고 저잡음 비밀 채널을 구축할 수 있는 캐시 공격을 활용한다. 따라서, 과도 명령 시퀀스는 섹션 3의 장난감 예와 유사하게 비밀을 마이크로아키텍처 캐시 상태로 인코딩해야 한다.

메모리에 프로브 배열을 할당하고 이 배열의 일부가 캐시되지 않도록 합니다. 비밀을 전송하기 위해, 과도 명령 시퀀스는 비밀(액세스 불가능) 값에 기초하여 계산되는 어드레스에 대한 간접 메모리 액세스를 포함한다. 목록 2의 5행에서 1단계의 비밀 값에 페이지 크기 _i.e_, \(4\,\mathrm{KB}\)를 곱합니다. 비밀의 곱셈은 배열에 대한 액세스들이 서로에 대한 큰 공간 거리를 갖는 것을 보장한다. 이것은 하드웨어 프리페처가 인접한 메모리 위치들을 캐시에 또한 로딩하는 것을 방지한다. 여기서 우리는 한 번에 한 바이트를 읽으므로, 우리의 프로브 배열은 \(4\,\mathrm{KB}\) 페이지를 가정하여 \(256\times 4096\) 바이트이다.

순서가 없는 실행에서는 레지스터 값 '0'에 대한 잡음 편향이 있다. 우리는 5.2절에서 이에 대한 이유를 논의한다. 그러나 이러한 이유로, 우리는 일시적 명령어 시퀀스에 재시도-로직을 도입한다. 우리가 '0'을 읽는 경우에, 우리는 비밀을 다시 읽으려고 한다(단계 1). 라인 7에서, 곱해진 비밀은 프로브 어레이의 베이스 어드레스에 추가되어, 커버트 채널의 타겟 어드레스를 형성한다. 이 어드레스는 대응하는 캐시 라인을 캐시하기 위해 판독된다. 결과적으로, 우리의 일시적 명령어 시퀀스는 단계 1에서 판독된 비밀 값에 기초하여 캐시 상태에 영향을 미친다.

단계 2의 과도 명령어 시퀀스는 예외를 높이는 것에 대해 경주하기 때문에, 단계 2의 런타임을 감소시키는 것은 공격의 성능을 상당히 향상시킬 수 있다. 예를 들어 프로브 배열에 대 한 주소 변환이 TLB에 캐시 됨을 주의 하면 일부 시스템에서 공격 성능이 증가 합니다.

3단계: 비밀 수신 단계 3에서 공격자는 캐시 상태(2단계)를 다시 아키텍처 상태로 전달하는 마이크로아키텍쳐 부채널 공격(_i.e._, 마이크로아키텍쳐 비밀 채널의 수신단)을 활용하여 비밀 값을 복구한다(1단계). 섹션 4.2에서 논의된 바와 같이, 멜트다운은 플러시+ 재로드에 의존하여 캐시 상태를 아키텍처 상태로 전달한다.

단계 2의 과도 명령 시퀀스가 실행될 때, 프로브 어레이의 정확히 하나의 캐시 라인이 캐싱된다. 프로브 어레이 내의 캐싱된 캐시 라인의 위치는 단계 1에서 판독되는 비밀에만 의존한다. 따라서, 공격자는 프로브 어레이의 모든 256 페이지에 걸쳐 반복하고 페이지 상의 모든 첫 번째 캐시 라인(_i.e._, 오프셋)에 대한 액세스 시간을 측정한다. 캐싱된 캐시 라인을 포함하는 페이지의 수는 비밀 값에 직접 대응한다.

전체 물리적 메모리를 덤프한다. 멜트다운의 세 단계를 모두 반복함으로써, 공격자는 모든 상이한 어드레스에 걸쳐 반복함으로써 전체 메모리를 덤프할 수 있다. 그러나 커널 주소에 대한 메모리 액세스가 프로그램을 종료하는 예외를 제기함에 따라, 예외를 처리하거나 억제하기 위해 섹션 4.1에 설명된 방법 중 하나를 사용한다.

모든 주요 운영체제는 또한 전형적으로 전체 물리적 메모리를 커널 어드레스 공간으로 매핑하기 때문이다(cf. 섹션 2.2). 모든 사용자 프로세스에서, 멜트다운은 커널 메모리를 판독하는 것에 한정되지 않고 타겟 머신의 전체 물리적 메모리를 판독할 수 있다.

### 최적화 및 제한 사항

0.액세스할 수 없는 커널 주소에서 읽으려고 하는 동안 예외가 트리거되는 경우 데이터가 저장되어야 하는 레지스터는 제로 아웃된 것으로 표시됩니다. 예외가 처리되지 않으면 사용자 공간 애플리케이션이 종료되고 충돌 프로세스의 코어 덤프에 저장된 레지스터 콘텐츠에서 액세스할 수 없는 커널 주소로부터의 값이 관찰될 수 있기 때문에 이것은 합리적이다. 이 문제를 해결하기 위한 직접적인 해결책은 해당 레지스터를 제로 아웃하는 것이다. 레지스터의 제로 아웃이 후속 명령(목록 2의 라인 5)의 실행보다 빠른 경우, 공격자는 제3 단계에서 잘못된 값을 판독할 수 있다. 과도 명령 시퀀스가 잘못된 값, _i.e._, '0'으로 계속되는 것을 방지하기 위해, 멜트다운은 '0'과 다른 값을 만날 때까지 어드레스를 판독하는 것을 재시도한다(라인 6). 예외가 상승된 후에 과도 명령 시퀀스가 종료됨에 따라, 비밀 값이 0이면 캐시 액세스가 없다. 따라서, Meltdown은 캐시 히트가 전혀 없다면 비밀 값이 실제로 '0'이라고 가정한다.

루프는 판독 값이 '0'이 아니거나 무효 메모리 액세스의 제기된 예외에 의해 종료된다. 이 루프는 공격을 측정가능하게 늦추지 않는데, 그 이유는, 어느 경우든, 전방이 루프인지 또는 전방이 선형 제어 흐름인지에 관계없이, 프로세서가 불법 메모리 액세스보다 앞서 실행되기 때문이다. 두 경우 모두 예외 처리 또는 예외 억제에서 반환된 제어 흐름이 이 루프의 유무에 관계없이 동일하게 유지된다. 따라서, 미리 판독 '0'을 캡처하고 손실된 경주 조건으로부터 조기에 회복하는 것은 판독 속도를 크게 증가시킨다.

5.1절의 공격 설명에서 공격자는 은밀한 채널을 통해 한번에 8비트를 전송하고 \(2^{8}=256\) Flush+ Reload 측정을 수행하여 비밀을 복구하였다. 그러나 더 많은 일시적인 명령어 시퀀스를 실행하는 것과 더 많은 플러시+ 재로드 측정을 수행하는 것 사이에는 분명한 트레이드오프가 있다. 공격자는 더 큰 데이터 값에 대해 MUV 명령을 사용하여 더 많은 비트를 읽음으로써 은밀한 채널을 통해 단일 전송에서 임의의 수의 비트를 전송할 수 있다. 또한, 공격자는 과도 명령 시퀀스에서 추가 명령을 사용하여 비트를 마스킹할 수 있다. 과도 명령 시퀀스에서 추가 명령의 수가 공격 성능에 무시할 수 있는 영향을 미친다는 것을 발견했다.

위의 일반적인 공격 설명에서 성능 병목 현상은 실제로 Flush+ 다시 로드 측정에 소요되는 시간입니다. 사실, 이 구현으로 거의 모든 시간이 플러시+재로드 측정에 소비될 것이다. 단일 비트만 전송하면 캐시 라인 1에서 측정한 Flush+Reload 측정값 _i.e_를 제외하고 모두 생략할 수 있습니다. 전송된 비트가 '1'인 경우 캐시 라인 1에서 캐시 히트를 관찰합니다. 그렇지 않은 경우 캐시 라인 1에서 캐시 히트를 관찰하지 않습니다.

한 번에 한 비트만 전송하는 것도 단점이 있다. 전술한 바와 같이, 우리의 사이드 채널은 '0'의 비밀 값에 대한 바이어스를 갖는다. 여러 비트를 한 번에 읽고 전송하면 모든 비트가 '0'일 가능성이 실제 사용자 데이터에 대해 상당히 작을 수 있다. 단일 비트가 '0'일 가능성은 전형적으로 50%에 가깝다. 따라서, 한번에 판독되고 전송되는 비트들의 수는 일부 암시적 에러-감소 및 은밀한 채널의 전체 전송 속도 사이의 트레이드오프이다.

그러나, 어느 경우에나 오차율이 상당히 작기 때문에, 우리의 평가(cf. 섹션 6) 는 단일 비트 전송 역학에 기초한다.

Intel TSX를 사용한 예외 억제.섹션 4.1에서는 애초에 메모리 액세스가 잘못되어 예외가 제기되는 것을 방지하기 위한 옵션에 대해 논의했다. 하드웨어 트랜잭션 메모리 구현인 Intel TSX를 사용하면 예외를 완전히 억제할 수 있다[17].

Intel TSX를 사용 하면 여러 명령을 트랜잭션으로 그룹화할 수 있으며, 트랜잭션은 원자 연산으로 표시 됩니다. _i.e._ 명령 모두 실행 되거나 실행 되지 않습니다. 트랜잭션 내의 하나의 명령이 실패하면 이미 실행된 명령은 되돌아가지만 예외는 제기되지 않는다.

만약 우리가 리스트 2의 코드를 그러한 TSX 명령으로 감싸면, 어떤 예외도 억제된다. 그러나, 마이크로아키텍처 효과들은 여전히 가시적이며, _즉_ 캐시 상태는 하드웨어 트랜잭션 내에서 지속적으로 조작된다[7]. 이는 예외를 억제하는 것이 예외를 처리하기 위해 커널에 트래핑하고 이후 계속하는 것보다 훨씬 빠르기 때문에 더 높은 채널 용량을 초래한다.

KASLR을 처리 합니다. 2013년에 KASLR (커널 주소 공간 레이아웃 무작위화)이 Linux 커널에 도입 되었습니다 (버전 3.14 [4]부터 시작). 부팅 시 커널 코드의 위치를 무작위화할 수 있습니다. 그러나 2017년 5월에야 KASLR이 버전 4.12 [27]에서 기본적으로 활성화되었다. KASLR을 사용하면 직접 물리적 지도가 랜덤화되어 특정 주소에서 고정되지 않으므로 공격자는 멜트다운 공격을 탑재하기 전에 랜덤화된 오프셋을 얻어야 한다. 그러나, 랜덤화는 40비트로 제한된다.

따라서 8GB RAM을 사용 하 여 대상 컴퓨터의 설정을 가정 하면 8GB 단계의 주소에 대 한 주소 공간을 테스트 하는 데 충분 합니다. 최악의 경우 128개의 테스트만으로 40비트의 검색 공간을 커버할 수 있습니다. 공격자가 테스트된 주소에서 값을 성공적으로 얻을 수 있는 경우 공격자는 해당 위치에서 전체 메모리를 덤프하는 작업을 진행할 수 있습니다. 이를 통해 몇 초 이내에 KASLR에 의해 보호됨에도 불구하고 시스템에 멜트다운을 장착할 수 있습니다.

## 6 Evaluation

이 섹션에서는 Meltdown과 개념 증명 구현 2의 성능을 평가한다. 섹션 6.1에서는 Meltdown이 누출할 수 있는 정보에 대해 논의하고 섹션 6.2에서는 대응 조치를 포함하여 Meltdown의 성능을 평가한다. 마지막으로 섹션 6.4에서 AMD와 ARM에 대한 제한 사항에 대해 논의한다.

각주 2: [https://github.com/IAIK/meltdown](https://github.com/IAIK/meltdown)

표 1은 멜트다운을 성공적으로 재현한 구성 목록을 보여준다. 멜트다운의 평가를 위해 인텔 코어 CPU가 있는 데스크톱 PC뿐만 아니라 노트북도 모두 사용했다. 클라우드 설정을 위해 아마존 탄성 컴퓨팅 클라우드에서 호스팅되는 인텔 제온 CPU에서 실행되는 가상 머신에서 멜트다운을 테스트했다.

디지털 오션에서도 마찬가지입니다. 윤리적인 이유로 우리는 다른 세입자의 물리적 기억을 언급하는 주소에 멜트다운을 사용하지 않았다.

### 정보 유출 및 환경

우리는 두 리눅스 모두에서 멜트다운을 평가했다(cf. 섹션 6.1.1). 및 윈도우 10(cf. 섹션 6.1.3). 두 운영 체제에서 멜트다운은 커널 메모리를 성공적으로 누출할 수 있습니다. 또한, KAISER 패치가 리눅스의 Meltdown에 미치는 영향을 평가하여 KAISER가 커널 메모리의 누설을 방지함을 보였다 (cf. 섹션 6.1.2). 마지막으로, 도커와 같은 컨테이너 내부를 실행할 때의 정보 유출에 대해 논의한다(cf. 섹션 6.1.4).

#### 6.1.1 Linux

2.6.32에서 4.13.0까지의 여러 버전의 리눅스 커널에서 Meltdown을 성공적으로 평가하였다. 이 모든 버전의 리눅스 커널에서 커널 주소 공간은 사용자 주소 공간에 매핑된다. 따라서, 모든 커널 어드레스들은 또한 사용자 공간 애플리케이션들의 어드레스 공간으로 맵핑되지만, 이들 어드레스들에 대한 허가 설정들로 인해 임의의 액세스가 방지된다. 멜트다운이 이러한 권한 설정을 우회함에 따라, 공격자는 커널 베이스의 가상 어드레스를 알고 있는 경우 완전한 커널 메모리를 누설할 수 있다. 모든 주요 운영체제는 또한 전체 물리적 메모리를 커널 어드레스 공간으로 매핑하기 때문이다(cf. 섹션 2.2). 또한, 모든 물리적 메모리를 판독할 수 있다.

커널 4.12 이전에, 커널 어드레스 공간 레이아웃 랜덤화(KASLR)는 디폴트로 활성화되지 않았다[30]. KASLR이 활성인 경우, 멜트다운은 어드레스 공간을 통해 검색함으로써 커널을 찾는 데 여전히 사용될 수 있다(cf. 섹션 5.2). 공격자는 또한 가상 어드레스 공간을 통해 반복함으로써 직접-물리 맵을 간단히 디-랜덤화할 수 있다. KASLR이 없으면, 직접-물리 맵은 어드레스 0xfff 8800 0000 0000에서 시작하여 전체 물리 메모리를 선형으로 매핑한다. 그러한 시스템들에서, 공격자는 Meltdown을 사용하여, 단순히 0xfff 8800 0000 0000에서 시작하는 가상 어드레스들로부터 판독함으로써, 전체 물리적 메모리를 덤프할 수 있다.

KASLR이 디폴트로 활성인 새로운 시스템들에서, 직접-물리 맵의 랜덤화는 40 비트로 제한된다. 매핑의 선형성으로 인해 더욱 제한된다. 타겟 시스템이 적어도 8GB의 물리적 메모리를 갖는다고 가정하면, 공격자는 8GB의 단계로 어드레스를 테스트할 수 있고, 그 결과 테스트할 최대 128개의 메모리 위치가 된다. 발견된 한 위치에서 시작하여 공격자는 다시 전체 물리적 메모리를 덤프할 수 있습니다.

따라서 평가를 위해 무작위화가 비활성화되었거나 사전 계산 단계에서 오프셋이 이미 검색되었다고 가정할 수 있다.

#### 6.1.2 Linux with KAISER Patch

Gruss 등의 [8]에 의한 KAISER 패치는 커널과 사용자 공간 사이의 더 강한 격리를 구현한다. KAISER는 x86 아키텍처에 의해 요구되는 일부 부분들(예를 들어, 인터럽트 핸들러들)을 제외하고, 사용자 공간 내의 임의의 커널 메모리를 매핑하지 않는다. 따라서, (직접-물리 맵을 통해) 사용자 공간에서 커널 메모리 또는 물리적 메모리 중 어느 하나에 대한 유효한 매핑이 없으며, 따라서 그러한 어드레스는 해결될 수 없다. 결과적으로 멜트다운은 사용자 공간에 매핑되어야 하는 몇 개의 메모리 위치를 제외하고는 커널이나 물리적 메모리를 누출할 수 없다.

우리는 KAISER가 실제로 멜트다운을 방지하고 커널이나 물리적 메모리의 누출이 없음을 확인했다.

또한 KASLR이 활성화되고 나머지 몇 개의 메모리 위치가 무작위로 지정되면 몇 킬로바이트의 작은 크기로 인해 이러한 메모리 위치를 찾는 것은 중요하지 않다. 섹션 7.2에서는 이러한 매핑된 메모리 위치의 의미를 보안 관점에서 논의한다.

#### 6.1.3 Microsoft Windows

우리는 최신 마이크로소프트 윈도우 10 운영 체제에서 멜트다운을 성공적으로 평가했다. Linux에 대 한 결과에 따라 (cf. 섹션 6.1.1) 또한 Meltdown은 Windows에서 임의 커널 메모리를 유출할 수 있습니다. 멜트다운은 소프트웨어 문제를 이용하지 않지만 하드웨어 문제로 인해 발생하기 때문에 이것은 놀라운 일이 아니다.

Linux와 달리 Windows는 물리적 메모리를 가상 주소 공간에 선형으로 매핑하는 ID 매핑 개념을 가지고 있지 않다. 대신에, 물리적 메모리의 큰 부분은 페이징된 풀들, 비페이징된 풀들 및 시스템 캐시에 매핑된다. 또한 Windows는 커널을 모든 응용 프로그램의 주소 공간에 매핑합니다. 따라서, 멜트다운은 커널 어드레스에 매핑되는 커널 메모리를 판독할 수 있다.

\begin{table}
\begin{tabular}{c c c} \hline \hline Environment & CPU model & Cores \\ \hline Lab & Celeron G540 & 2 \\ Lab & Core i5-3230M & 2 \\ Lab & Core i5-3320M & 2 \\ Lab & Core i7-4790 & 4 \\ Lab & Core i5-6200U & 2 \\ Lab & Core i7-6600U & 2 \\ Lab & Core i7-6700K & 4 \\ Cloud & Xeon E5-2676 v3 & 12 \\ Cloud & Xeon E5-2650 v4 & 12 \\ \hline \hline \end{tabular}
\end{table}
표 1: 실험 설정.

space, _i.e._, 스왑 아웃되지 않은 커널의 임의의 부분, 및 페이징된 풀 및 페이징되지 않은 풀에 매핑된 임의의 페이지, 및 시스템 캐시를 포함할 수 있다.

한 프로세스에는 매핑되지만 다른 프로세스의 (커널) 주소 공간에는 매핑되지 않는 물리적 페이지 _i.e._, Meltdown을 사용하여 공격할 수 없는 물리적 페이지가 있을 수 있습니다. 그러나 대부분의 물리적 메모리는 멜트다운을 통해 여전히 액세스할 수 있습니다.

우리는 멜트다운을 사용하여 윈도우 커널의 이진수를 성공적으로 읽을 수 있었다. 유출된 데이터가 실제 커널 메모리인지 확인하기 위해 먼저 윈도우 커널 디버거를 사용하여 실제 데이터가 포함된 커널 주소를 얻었다. 데이터를 유출한 후 다시 윈도우 커널 디버거를 사용하여 유출된 데이터와 실제 메모리 내용을 비교하여 멜트다운이 커널 메모리를 성공적으로 유출할 수 있음을 확인했다.

#### 6.1.4 Containers

우리는 도커, LXC, OpenVZ를 포함한 커널을 공유하는 컨테이너에서 실행되는 멜트다운을 평가했으며 공격이 제한 없이 탑재될 수 있음을 발견했다. 컨테이너 내부에서 Meltdown을 실행하면 기본 커널뿐만 아니라 동일한 물리적 호스트에서 실행되는 다른 모든 컨테이너에서도 정보를 유출할 수 있습니다.

대부분의 컨테이너 솔루션의 공통점은 모든 컨테이너가 동일한 커널 _즉_ 을 사용 하 여 모든 컨테이너 간에 커널이 공유 된다는 것입니다. 따라서, 모든 컨테이너는 공유된 커널의 직접-물리 맵을 통해 전체 물리 메모리의 유효한 맵핑을 갖는다. 또한 메모리 액세스만 사용하기 때문에 컨테이너에서 멜트다운을 차단할 수 없습니다. 특히 Intel TSX에서는 커널에 트래핑하지 않고 권한 없는 명령만 실행됩니다.

따라서, 커널을 공유하는 컨테이너들의 격리는 멜트다운을 사용하여 완전히 깨질 수 있다. 이것은 사용자가 완전히 가상화된 기계를 통해 분리되지 않고 컨테이너를 통해서만 분리되는 더 저렴한 호스팅 제공자에게 특히 중요하다. 본 논문에서 제안하는 공격은 다른 사용자의 컨테이너에서 메모리 내용을 성공적으로 유출함으로써 이러한 환경에서 동작함을 확인하였다.

### Meltdown Performance

멜트다운의 성능을 평가하기 위해 커널 메모리에서 알려진 값을 유출하였다. 이를 통해 공격자가 메모리를 얼마나 빨리 유출할 수 있는지 확인할 수 있을 뿐만 아니라 오류 비율 _i.e._, 예상 바이트 오류 수를 확인할 수 있습니다. 예외 억제를 사용할 때 최대 \(503\,\mathrm{KB/s}\)의 평균 읽기율을 얻었으며, 오류율은 \(0.02\,\mathrm{\char 37}\)로 낮았다. 성능평가를 위해 Intel TSX를 지원하는 Intel Core i7-6700K를 중심으로 예외처리와 예외억제의 공정한 성능비교를 수행하였다.

모든 테스트에서는 Flush+Reload를 비밀 채널로 사용하여 섹션 5에 설명된 대로 메모리를 누출한다. 예외 처리 및 예외 억제의 성능을 평가했다(cf. 섹션 4.1). 예외 처리를 위해 신호 처리기를 사용했으며 CPU가 지원하는 경우 Intel TSX를 사용하여 예외 억제도 사용했다. 조건부 분기를 사용한 예외 억제에 대한 광범위한 평가는 Kocher et al. [19]에 의해 수행되었으며 따라서 간결함을 위해 본 논문에서는 생략되었다.

#### 6.2.1 Exception Handling

예외 처리는 CPU 확장에 의존하지 않으므로 제한 없이 사용할 수 있으므로 보다 보편적인 구현입니다. 예외 처리를 위한 유일한 요구 사항은 세분화 오류를 캐치하고 이후 작업을 계속하기 위한 운영 체제 지원입니다. 이는 운영 체제들 간에 구체적인 구현이 상이함에도 불구하고, 모든 현대 운영 체제들에 대한 경우이다. 리눅스에서는 신호를 사용하는 반면, 윈도우에서는 구조화된 예외 처리기에 의존했다.

예외처리를 통해 커널 메모리의 \(12\,\mathrm{MB}\)이 누출되었을 때 평균 읽기 속도 \(123\,\mathrm{KB/s}\)을 달성하였다. \(12\,\mathrm{MB}\) 커널 데이터 중 \(0.03\,\mathrm{\char 37}\)만 잘못 읽혀졌다. 따라서 에러율이 \(0.03\,\mathrm{\char 37}\)일 때 채널 용량은 \(122\,\mathrm{KB/s}\)이다.

#### 6.2.2 Exception Suppression

예외 억제는 조건부 브랜치를 사용하거나 Intel TSX를 사용하여 달성될 수 있다. 조건부 분기는 Kocher 등 [19]에서 자세히 다루므로 예외 억제를 위해 Intel TSX만 평가한다. 예외 처리와 달리 인텔 TSX는 명령어 집합 확장이기 때문에 운영체제 지원이 필요하지 않다. 그러나 인텔 TSX는 다소 새로운 확장이므로 브로드웰 마이크로 아키텍처 이후 최근 인텔 CPU에서만 사용할 수 있다.

또한 성능 측정을 위해 커널 메모리의 \(12\,\mathrm{MB}\)을 유출하였다. 예외 억제를 통해 평균 읽기 속도 \(503\,\mathrm{KB/s}\)을 달성하였다. 또한 예외처리에 의한 에러율 \(0.02\,\mathrm{\char 37}\)은 예외처리에 의한 에러율보다 훨씬 낮다. 따라서 예외 억제를 통해 얻을 수 있는 채널 용량은 \(502\,\mathrm{KB/s}\)이다.

### Meltdown for Practice

Listing 3은 Linux 커널 4.8.0으로 Ubuntu 16.10을 실행하는 Intel Core i7-6700K에서 Meltdown을 사용하여 메모리 덤프를 보여줍니다. 이 예에서는 Linux 커널 4.8.0을 사용하여 Ubuntu 16.10을 실행하는 Meltdown을 사용하여 메모리 덤프를 식별할 수 있습니다.

[MISSING_PAGE_EMPTY:13]

하드웨어 자체, 우리는 가능한 마이크로코드 업데이트와 하드웨어 설계의 일반적인 변경에 대해 논의하고자 합니다. 둘째, KASLR에 대한 부채널 공격을 완화하기 위해 개발된 KAISER 대응방안에 대해 논의하고자 한다.

### Hardware

용융은 하드웨어로 강화된 보안 도메인 격리를 우회합니다. 멜트다운에 관련된 소프트웨어 취약성이 없습니다. 따라서, 임의의 소프트웨어 패치(예를 들어, KAISER [8])는 소량의 메모리를 노출시킬 것이다(cf. 섹션 7.2). 그러한 수정은 완전히 새로운 하드웨어의 개발을 필요로 하는지 또는 마이크로코드 업데이트를 사용하여 수정될 수 있는지에 대한 문서는 없다.

멜트다운이 비순서적 실행을 악용함에 따라, 사소한 대응책은 비순서적 실행을 완전히 무력화하는 것이다. 그러나 현대 CPU의 병렬성을 더 이상 활용할 수 없기 때문에 성능 영향은 파괴적일 것이다. 따라서, 이것은 실행 가능한 해결책이 아니다.

멜트다운은 메모리 어드레스의 페치와 이 어드레스에 대한 대응하는 허가 체크 사이의 경주 조건의 일부 형태이다. 권한 체크와 레지스터 페치를 직렬화하는 것은, 권한 체크에 실패하는 경우 메모리 어드레스가 결코 페치되지 않기 때문에, 멜트다운을 방지할 수 있다. 그러나, 이것은 권한 검사가 완료될 때까지 메모리 페치가 정지해야 하기 때문에 모든 메모리 페치에 상당한 오버헤드를 수반한다.

더 현실적인 해결책은 사용자 공간과 커널 공간의 하드 분할을 도입하는 것이다. 이것은 CPU 제어 레지스터, 예를 들어 CR4에서 새로운 하드-분할 비트를 사용하는 현대의 커널들에 의해 선택적으로 인에이블될 수 있다. 하드-분할 비트가 설정되면, 커널은 어드레스 공간의 상반부에 상주해야 하고, 사용자 공간은 어드레스 공간의 하반부에 상주해야 한다. 이러한 하드 스플릿으로, 메모리 페치는 임의의 추가 룩업 없이 권한 레벨이 가상 어드레스로부터 직접 도출될 수 있기 때문에, 목적지의 그러한 페치가 보안 경계를 위반할 것인지 여부를 즉시 식별할 수 있다. 이러한 솔루션의 성능 영향은 최소화될 것으로 예상합니다. 또한, 하드 분할 비트는 기본적으로 설정되지 않고 커널은 하드 분할 기능을 지원하는 경우에만 설정하기 때문에 역 호환성이 보장된다.

이러한 대응법들은 Meltdown만을 방지할 뿐, Kocher 등[19]에 의해 기술된 Spectre 공격의 부류는 방지하지 않는다는 점에 유의한다. 마찬가지로, Kocher 등[19]에 의해 제시된 몇 가지 대응책은 Meltdown에 영향을 미치지 않는다. 우리는 두 공격 모두에 대한 대응책을 배치하는 것이 중요하다고 강조한다.

### Kaiser

하드웨어는 패치하기가 쉽지 않기 때문에, 새로운 하드웨어가 배치될 수 있을 때까지 소프트웨어 해결 방법이 필요하다. Gruss et al. [8]은 사용자 공간에서 매핑된 커널을 갖지 않도록 하는 커널 수정인 KAISER을 제안하였다. 이러한 수정은 KASLR을 깨는 부채널 공격을 방지하기 위한 것이었다[13, 9, 17]. 그러나, 사용자 공간에서 이용가능한 커널 공간 또는 물리적 메모리에 대한 유효한 매핑이 없음을 보장하기 때문에 멜트다운을 방지하기도 한다. KAISER는 커널 페이지-테이블 격리(KPTI)라는 이름으로 리눅스 커널의 다가오는 릴리즈에서 이용가능할 것이다[25]. 패치는 이전 Linux 커널 버전으로 백포트됩니다. 유사한 패치가 마이크로소프트 윈도우 10 Build 17035 [15]에도 도입되었다. 또한 Mac OS X와 iOS는 유사한 기능을 가지고 있다[22].

KAISER는 멜트다운에 대한 기본적인 보호를 제공하지만 여전히 몇 가지 한계를 가지고 있다. x86 아키텍처의 설계로 인해, 몇몇 특권 메모리 위치들이 사용자 공간[8]에서 매핑될 것이 요구된다. 이것은 Meltdown, _i.e._에 대한 잔여 공격 표면을 남긴다. 이러한 메모리 위치는 여전히 사용자 공간으로부터 판독될 수 있다. 이러한 메모리 위치에는 자격 증명과 같은 비밀이 포함되어 있지 않더라도 포인터가 포함되어 있을 수 있습니다. 임의화가 포인터 값으로부터 계산될 수 있기 때문에, 하나의 포인터를 누설하는 것은 KASLR을 다시 깨기에 충분할 수 있다.

그러나 KAISER는 현재 사용 가능한 최고의 단기 솔루션이므로 모든 시스템에 즉시 배치되어야 한다. 멜트다운을 사용하더라도, KAISER는 랜덤화된 오프셋들에 대한 정보를 누설할 사용자 공간 내에 매핑되는 메모리 위치들에 대한 임의의 커널 포인터들을 갖는 것을 피할 수 있다. 이렇게 하려면 모든 커널 포인터에 대 한 트램폴린 위치가 필요 합니다. _i.e._ 인터럽트 처리기는 직접 커널 코드를 호출 하는 것이 아니라 트램폴린 함수를 통해 호출 됩니다. 트램폴린 함수는 커널에서만 매핑되어야 합니다. 나머지 커널과 다른 간격띄우기로 랜덤화해야 합니다. 결과적으로 공격자는 트램폴린 코드로 포인터만 유출할 수 있지만 나머지 커널의 무작위 오프셋은 유출할 수 없다. 이러한 트램폴린 코드는 사용자 공간에서 여전히 매핑되어야 하고 커널 주소를 포함하는 모든 커널 메모리에 필요하다. 이 접근법은 향후 작업에서 평가해야 하는 성능과 보안 사이의 절충안이다.

## 8 Discussion

멜트다운은 마이크로 아키텍처 요소의 상태를 조작하는 하드웨어 최적화의 보안에 대한 우리의 관점을 근본적으로 변화시킨다. 하드웨어 최적화가 마이크로아키텍처 엘리먼트들의 상태를 변경할 수 있고, 그에 따라 보안 소프트 웨어 구현들을 위태롭게 할 수 있다는 사실은 20년 이상 전부터 알려져 있다[20]. 지금까지 산업계와 과학계 모두 이를 효율적인 컴퓨팅을 위한 필요악으로 받아들였다. 오늘날 암호 알고리즘이 하드웨어 최적화에 의해 도입된 미세 구조 누출로부터 보호되지 않을 때 버그로 간주된다. 멜트다운은 상황을 완전히 바꿔놓는다. 멜트다운은 캐시 공격에 대해 수백 사이클마다 64-바이트와 같은 비교적 낮은 공간적 및 시간적 세분성에서 임의의 세분성으로 세분성을 이동시켜 공격자가 모든 단일 비트를 읽을 수 있게 한다. 이것은 어떤 암호화 알고리즘도 스스로를 보호할 수 있는 것이 아니다. 카이저는 단기 소프트웨어 수정이지만 우리가 발견한 문제는 훨씬 더 중요하다.

우리는 캐시를 통해서가 아니라 어떤 방식으로든 마이크로 아키텍처 상태에 영향을 미치는 현대 CPU에서 몇 가지 더 많은 성능 최적화를 기대한다. 따라서, 신뢰할 수 없는 코드를 실행하는 CPU와 같은 특정 보안 보장을 제공하도록 설계된 하드웨어는 멜트다운 및 스펙터-유사 공격을 피하기 위해 재설계가 필요하다. 멜트다운은 또한 부채널 공격을 막기 위해 명시적으로 작성된 오류가 없는 소프트웨어도 기본 하드웨어의 설계를 고려하지 않으면 안전하지 않다는 것을 보여준다.

KAISER가 모든 주요 운영체제에 통합됨에 따라 멜트다운을 방지하기 위한 중요한 단계가 이미 수행되었다. 카이저는 운영체제의 패러다임 변화의 첫 단계이기도 하다. 모든 것을 항상 주소 공간에 매핑하는 대신 최소로 필요한 메모리 위치만 매핑하는 것이 공격 표면을 줄이는 첫 번째 단계로 보인다. 그러나 충분하지 않을 수 있으며 훨씬 더 강력한 격리가 필요할 수 있다. 이 경우, 예를 들어 모든 운영 체제에 대해 특정 가상 메모리 레이아웃을 강제함으로써 성능과 보안을 위한 유연성을 교환할 수 있습니다. 대부분의 현대의 운영체제는 이미 기본적으로 동일한 메모리 레이아웃을 사용하기 때문에, 이것은 유망한 접근법일 수 있다.

멜트다운은 특히 게스트가 완전히 가상화되지 않은 경우 클라우드 제공업체에 심각한 영향을 미칩니다. 성능상의 이유로, 많은 호스팅 또는 클라우드 제공자들은 가상 메모리에 대한 추상화 계층을 갖지 않는다. 일반적으로 Docker 또는 OpenVZ와 같은 컨테이너를 사용하는 이러한 환경에서는 커널이 모든 게스트 간에 공유됩니다. 따라서 게스트 간의 격리는 멜트다운으로 간단히 우회하여 동일한 호스트에 있는 다른 모든 게스트의 데이터를 완전히 노출할 수 있다. 이러한 공급자의 경우 인프라를 완전한 가상화로 변경하거나 KAISER와 같은 소프트웨어 해결 방법을 사용하면 비용이 크게 증가한다.

멜트다운이 확정되더라도 스펙터[19]는 여전히 쟁점으로 남을 것이다. 스펙터[19]와 멜트다운은 다른 방어가 필요하다. 특히 그 중 하나만 완화하면 전체 시스템의 보안이 위험에 빠집니다. 우리는 Meltdown과 Spectre가 새로운 연구 분야를 열어 성능 최적화가 미세구조 상태를 어느 정도 변화시키는지, 이 상태가 어떻게 아키텍처 상태로 변환될 수 있는지, 그리고 그러한 공격을 어떻게 방지할 수 있는지 조사할 것으로 기대한다.

## 9 Conclusion

본 논문에서는 비권한 사용자 공간 프로그램에서 임의의 커널 및 물리 메모리 위치를 읽기 위해 Intel CPU에서 비순서적 실행을 이용하는 새로운 소프트웨어 기반 부채널 공격인 Meltdown을 제안한다. 멜트다운(Meltdown)은 소프트웨어 취약성을 요구하지 않고 운영체제와는 무관하게 클라우드 내의 다른 프로세스나 가상 머신의 민감한 데이터를 최대 \(503\,\mathrm{KB/s}\)까지 판독하여 수백만 개의 장치에 영향을 줄 수 있다. KASLR에 대한 부채널 공격으로부터 보호하기 위해 제안된 KAISER [8]이 의도하지 않게 Meltdown을 방해한다는 것을 보여주었다. 우리는 KAISER가 멜트다운의 대규모 개발을 방지하기 위해 멜트다운이 하드웨어로 고정될 때까지 단기적인 해결책으로 모든 운영 체제에 배치될 필요가 있다고 강조한다.

## Acknowledgment

우리는 궁극적으로 멜트다운의 발견으로 이어진 블랙햇 USA 2016과 블랙햇 유럽 2016에서 알찬 논의를 한 앤더스 포그에 감사드린다. Fogh [5]는 이미 사용자 모드에서 커널 메모리를 읽기 위해 추측 실행을 악용할 수 있다고 의심했지만 그의 실험은 성공하지 못했다. 우리는 또한 초기 초안에 대한 논평에 대해 Jann Horn에게 감사하고 싶습니다. Jann은 그 문제를 6월에 Intel에 공개했다. KAISER 패치 주변의 후속 활동이 이 문제를 조사하기 시작한 이유였다. 또한 초기 초안에 대한 피드백을 위해 인텔, ARM, 퀄컴 및 Microsoft를 원합니다.

또한 인텔이 책임 있는 공개 프로세스에 대해 버그 현상금을 수여하고 명확한 시간표를 전달하고 관련된 모든 연구원을 연결하여 이 문제를 전문적으로 처리해 준 것에 감사드린다. 또한 ARM이 이 문제를 공개할 때 신속하게 응답해 주셔서 감사합니다.

이 작업은 유럽 연합의 Horizon 2020 연구 및 혁신 프로그램(무상 협정 번호 681402)에 따라 유럽 연구 위원회(ERC)에 의해 부분적으로 지원되었다.

## References

*[1]Benger, N., van de Pol, J., Smart, N. P., and Yarom, Y. "오, 아... 단지 약간의 비에프" 작은 양의 부채널은 먼 길을 갈 수 있습니다. In _CHES'14_ (2014).
*[2]Cheng, C.-C. 동적 분기 예측 변수의 구성 및 성능입니다. _ (주)버클리 무선연구센터 Rep_(2000).
* [3]Devies, A. M. AMD Takes Computing to a New Horizon with RyzenTMProcessors, 2016.
*[4]Edge, J. Kernel address space layout randomization, 2013.
* [5]Fogh, A. Negative Result: Reading Kernel Memory From User Mode, 2017.
*[6]Gras, B., Razavi, K., Bosman, E., Bos, H., and Giuffrida, C. ASLR on the Line: Practical Cache Attacks on the MMU. In _NDSS_ (2017).
*[7]Gruss, D., Lettner, J., Schuster, F., Ohrimenko, O., Haller, I., and Costa, M. 하드웨어 트랜잭션 메모리를 사용한 강력하고 효율적인 캐시 부채널 보호 _USENIX Security Symposium_(2017).
*[8]Gruss, D., Lipp, M., Schwarz, M., Fellner, R., Maurice, C., and Mangard, S. KASLR은 죽었다: Long Live KASLR. _International Symposium on Engineering Secure Software and Systems_ (2017), Springer, pp. 161-176.
*[9]Gruss, D., Maurice, C., Fogh, A., Lipp, M., and Mangard, S. 부채널 공격 미리 가져오기: SMAP 및 커널 ASLR을 우회합니다. In _CCS_ (2016).
*[10]Gruss, D., Maurice, C., Wagner, K., and Mangard, S. 플러시+플러시: 빠르고 은밀한 캐시 공격. _DIMVA_(2016).
* [11]Gruss, D., Spreitzer, R., and Mangard, S. 캐시 템플릿 공격: 포함 마지막 수준 캐시에 대한 공격 자동화 _USENIX Security Symposium_(2015).
* [12]Hennessy, J. L., and Patterson, D. A. _Computer architecture: quantitative approach._ 2011년, 엘세비어
* [13]Hund, R., Willems, C., and Holz, T. 커널 스페이스 ASLR에 대한 실용적인 타이밍 사이드 채널 공격 In _S&P_ (2013).
*[14]Intel. 인텔(r) 64 및 IA-32 아키텍처 최적화 참조 매뉴얼, 2014.
* [15]Ionescu, A. Windows 17035 Kernel ASLR/VA Isolation In Practice (like Linux KAISER)., 2017.
* [16]Irazoqui, G., Inci, M. S., Eisenbarth, T., and Sunar, B. Wait minute! AES에 대한 빠른 크로스VM 공격입니다. In _RAID'14_ (2014).
*[17]Jang, Y., Lee, S., and Kim, T. 인텔 TSX를 사용한 커널 주소 공간 배치 랜덤화 중단 In _CCS_ (2016).
* [18]Jimenez, D. A., and Lin, C. Dynamic branch prediction with perceptron. In _High-Performance Computer Architecture, 2001. HPCA. The Seventh International Symposium on_(2001), IEEE, pp. 197-206.
*[19]Kocher, P., Genkin, D., Gruss, D., Haas, W., Hamburg, M., Lipp, M., Mangard, S., Prescher, T., Schwarz, M., and Yarom, Y. 스펙터 공격: 추측 실행을 사용합니다.
* [20]Kocher, P. C. Timing Attacks on Implementations of Diffe-Hellman, RSA, DSS and Other Systems. _CRIPTO_(1996).
* [21] Lee, B., Malishevsky, A., Beck, D., Schmid, A., and Landry, E. Dynamic branch prediction. _ 오리건 주립대학교_
*[22]Levin, J. _Mac OS X and IOS Internals: To the Apple's Core_. 존 와일리 앤 선즈, 2012년
* [23]Lipp, M., Gruss, D., Spreitzer, R., Maurice, C., and Mangard, S. ARMageddon: 모바일 장치에 대한 캐시 공격입니다. _USENIX Security Symposium_(2016).
*SP_(2015), IEEE Computer Society, pp.605-622.
*[25]LWN. 12월 커널 페이지 테이블 격리 상태. 2017년
*[26]Maurice, C., Weber, M., Schwarz, M., Giner, L., Gruss, D., Alberto Boano, C., Mangard, S., and Romer, K. 다른 쪽에서 온 안녕하세요: 클라우드에서 강력한 캐시 커버 채널을 통한 SSH입니다. In _NDSS_ (2017).
* [27]Molnar, I. 886: Enable KASLR by default, 2017.
*[28]Osvik, D. A., Shamir, A., and Tromer, E. Cache Attack and Countermeasures: the Case of AES. In _CT-RSA_ (2006).
* [29]Percival, C. Cache missing for fun and profit. _Proceedings of BSDCan_ (2005).
*[30]Phoronik. Linux 4.12 To Enable KASLR By Default, 2017.
*[31]Schwarz, M., Lipp, M., Gruss, D., Weiser, S., Maurice, C., Spreitzer, R., and Mangard, S. 키드롭: 소프트웨어 기반 키스트로크 타이밍 부채널 공격 제거 In _NDSS'18_ (2018).
* [32]Teran, E., Wang, Z., and Jimenez, D. A. Perceptron learning for reuse prediction. _Microarchitecture(MICRO), 2016 제49회 Annual IEEE/ACM International Symposium on_(2016), IEEE, pp.1-12.
* [33]Tomasulo, R. M. An efficient algorithm for exploit of multiple arithmetic units. _ IBM Journal of Research and Development 11_, 1(1967), 25-33.
*[34]Vintan, L. N., and Iridon, M. 고성능 신경 분기 예측기를 향합니다. In _Neural Networks, 1999. IJCNN'99. International Joint Conference on_ (1999), vol. 2, IEEE, pp. 868-873.
*[35]Yarom, Y., and Falkner, K. Flush+Reload: 고해상도, 저잡음, L3 캐쉬 부채널 공격. _USENIX Security Symposium_(2014).
*[36]Yeh, T. -Y., 및 Patt, Y. N. Two-level adaptive training branch prediction. Proceedings of the 24th annual international symposium on Microarchitecture_(1991), ACM, pp.51-61.
* [37]Zhang, Y., Juels, A., Reiter, M. K., and Ristenpart, T. PaaS 클라우드에서 테넌트 간 부채널 공격 In _CCS'14_ (2014).
